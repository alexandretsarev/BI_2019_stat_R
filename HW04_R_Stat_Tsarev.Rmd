---
title: "Домашняя работа №4, R and Statistics"
author: "Царев Александр"
date: "Октябрь 19, 2019"
output:
  html_document: default
  pdf_document: default
---

## Задание
1. (обязательное) Напишите пользовательскую функцию, которая на вход будет принимать датафрейм из двух колонок (в которых гарантированно находятся числа) и считает и выводит значение коэффициента корреляции Пирсона. (к 02.11)
2. (дополнительное) Напишите пользовательскую функцию, которая на вход будет принимать датафрейм из двух колонок (в которых гарантированно находятся числа) и считает и выводит значение коэффициента корреляции Спирмена. Дополнительной опцией может быть вариант, когда у вас одна функция и пользователь может указать, какой тип корреляции он хочет посчитать (к 02.11)


## Решение
Для начала нужно определиться с формулами для вычисления коэффициентов корреляции Пирсона и Спирмена

_Коэффициент корреляции Пирсона_: $$r = \frac{{}\sum_{i=1}^{n} (x_i - \overline{x})(y_i - \overline{y})}
{\sqrt{\sum_{i=1}^{n} (x_i - \overline{x})^2(y_i - \overline{y})^2}}$$
_Коэффициент корреляции Спирмена_: $$\rho = 1- {\frac {6 \sum_{i=1}^{n} d_i^2}{n(n^2 - 1)}}$$

Где $d$ = попарные расстояния рангов переменных $x_i$ and $y_i$, а $n$ = количество образцов


Можно было сделать одну функцию с пользовательским выбором типа корреляции, так я и сделал. Также отмечу, что функция не проверяет есть ли _NA_ в датасете. Подразумевается, что пользователь препроцессировал свой датасет, чтобы функция сработала (выкинул _NA_ или сделал импутацию). Также в задании не нужно проверять тип входных данных, они по умолчанию являются _numeric_


```{r, echo=TRUE}

corr_fun <- function(your_data, method){
  
  if (method == "pearson"){
    your_data$delta1 <- your_data[,1]-mean(your_data[,1]) # вектор вариаций между значением и средним по значению X1 
    your_data$delta2 <- your_data[,2]-mean(your_data[,2]) # вектор вариаций между значением и средним по значению X2
    your_data$muldel <- your_data$delta1*your_data$delta2 # вектор переменоженных вариаций двух переменных (X1*X2)
    numerator <- sum(your_data$muldel) # по сути это готовый числитель, лучше подсчитать 1 раз -> экономия времени
    
    your_data$delta1_sq <- sapply(your_data$delta1,function(x) x^2) #  векотр квадратов вариаций по значению X1
    your_data$delta2_sq <- sapply(your_data$delta2,function(x) x^2) #  векотр квадратов вариаций по значению X2
    
    denominator <- sqrt(sum(your_data$delta1_sq)*sum(your_data$delta1_sq))# по сути это готовый знаменатель
    
    return(numerator/denominator)
    
  } else if (method == "spearman") {
    
    n <- length(df[,1]) # количество наблюдений
    df <- df[order(df[,1]),] # сортируем по первой колонке от меньшего к большему
    df$X1_rang <- seq(1,n,1) # добавляем ранги 1 -> n
    df <- df[order(df[,2]),] # сортируем по второй колонке от меньшего к большему
    df$X2_rang <- seq(1,n,1) # добавляем ранги 1 -> n
    
    df$d_sq <- (df$X1_rang-df$X2_rang)^2 # получаем квадрат разницы между рангами переменных
    
    return(1-6*sum(df$d_sq)/(n*((n^2)-1)))
  }
}

```

# Проверка правильности функции
Генерируем рандомный датасет

```{r, echo=TRUE}
df <- data.frame(replicate(2,sample(-1000:1000,50)))
```
Тестируем написанную функцию с той, что встроена в R

Видим что получаются одинаковые значения, все ок
```{r, echo=TRUE}

corr_fun(your_data = df,method = "pearson")
cor(df,method = "pearson")[1,2] # вытаскиваю "недиагональное значение"

corr_fun(your_data = df,method = "spearman")
cor(df,method = "spearman")[1,2] # вытаскиваю "недиагональное значение"


```




